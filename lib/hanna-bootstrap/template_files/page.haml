- entry = values[:entry]
- file_page = !values[:classmod]
- methods = entry.method_list + entry.attributes
- description = entry.description
- title_in_description = description && (description =~ /<h(1|2[^>]*?)>/i)
- description.gsub!(%r{<h(1|2)[^>]*?>(?<tag>.*?)</h(1|2)>}){|m| %Q[<div class="page-header">#{m}</div>] }

.row
  .span9
    - if title_in_description
      .name= values[:title]
    - else
      .page-header
        %h1.name
          = values[:title]
    %section
      #text
        - if values[:description]
          #description~ sanitize_code_blocks values[:description]
        - sections = values[:sections].keys if values.has_key?(:sections)

        - if entry.requires or sections or entry.includes
          #context
            - unless entry.requires.empty?
              - no_content = false
              %section#requires
                %h2 Required files
                %ol
                  - entry.requires.each do |req|
                    %li= req.name

            - if sections && (sections.length > 1 || sections.first.title.to_s != '')
              - no_content = false
              %section#contents
                %h2 Contents
                %ol
                  - sections.sort_by{|s| s.title.to_s}.each do |section|
                    %li= link_to section.title, "##{section.aref}"

            - unless entry.includes.empty?
              - no_content = false
              %section#includes
                %h2 Included modules
                %ol
                  - entry.includes.each do |inc|
                    - if (mod = inc.module).is_a?(String)
                      %li= inc.name
                    - else
                      %li= link_to inc.name, entry.aref_to(mod.path)



  .span3
    %ul.nav.nav-list

      - if file_page
        %li.nav-header Path
        %li= values[:file].relative_name

      - else
        %li.nav-header Defined IN
        - values[:entry].in_files.each_with_index do |file, index|
          %li
            = link_to file.full_name, Pathname.new(file.path).relative_path_from(Pathname.new(values[:entry].path).dirname)

      - if values[:entry].parent
        %li.nav-header Parent
        %li
          %strong
            = link_to values[:entry].parent.name, Pathname.new(class_dir) + Pathname.new(values[:entry].parent.path).relative_path_from(Pathname.new values[:entry].path)

      - if values[:entry].respond_to?(:last_modified) and values[:entry].last_modified
        %li.nav-header Last Update
        %li
          %span.datetime= values[:entry].last_modified

      - unless methods.empty?
        %li.divider
        - %w[attr attr_accessor attr_reader attr_writer class instance].each do |type|
          - (RDoc::VISIBILITIES rescue RDoc::Context::VISIBILITIES).each do |vis|
            - list = methods.reject { |x| x.respond_to?(:is_alias_for) && x.is_alias_for }.select { |x| x.visibility == vis && x.type == type.to_s }.sort
            - unless list.empty?
              - type_result = ""
              - if type =~ /^attr_/
                - type_result += type.sub(/^attr_/, '').capitalize
              - else
                - type_result += type.capitalize
              - type_result = "#{vis.to_s.capitalize} #{type_result}"
              %li.nav-header= type_result
              - list.each do |method|
                - if method.respond_to?(:aref)
                  - if method.name.to_s.empty? && method.call_seq
                    %li= link_to method.call_seq.gsub(/<br\s*\/?>/, "").split(/[\r\n]+/).map{ |s| s.split(/([({]+|\[\{|\s+(#?=>|&rarr;)\s+)/).first.sub(/^[A-Za-z0-9_:]+\./, "").sub(/\s+=\s+.*/, "=").strip }.uniq.join("<br />\n"), '#' + method.aref
                  - else
                    %li= link_to method.name, '#' + method.aref
                - elsif method.respond_to?(:html_name)
                  %li= link_to method.name, "#method-#{method.html_name}"
                - else
                  %li= method.name


